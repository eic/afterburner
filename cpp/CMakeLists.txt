# building examples
#------------------
project(EICAfterburner)
cmake_minimum_required(VERSION 3.10.0 FATAL_ERROR)
include_directories(${PROJECT_SOURCE_DIR}/include )


#This is needed for standalone compilation
find_package(HepMC3 REQUIRED)

message(STATUS "HEPMC3_INCLUDE_DIR: ${HEPMC3_INCLUDE_DIR}")
message(STATUS "HEPMC3_LIBRARIES: ${HEPMC3_LIBRARIES}")
include_directories(${HEPMC3_INCLUDE_DIR})
include(GNUInstallDirs)
include(CheckCXXCompilerFlag)
if (HEPMC3_ROOTIO_LIB)
    set (ROOT_FIND_COMPONENTS Core RIO Tree)
    list(APPEND CMAKE_PREFIX_PATH $ENV{ROOTSYS})
    list(APPEND CMAKE_PREFIX_PATH ${ROOT_DIR})
    find_package(ROOT REQUIRED COMPONENTS Core RIO Tree)
    set(CMAKE_CXX_FLAGS_BEFORE_ROOT "${CMAKE_CXX_FLAGS}")
    set(CMAKE_C_FLAGS_BEFORE_ROOT "${CMAKE_C_FLAGS}")
    set(CMAKE_Fortran_FLAGS_BEFORE_ROOT "${CMAKE_Fortran_FLAGS}")
    include(${ROOT_USE_FILE})
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS_BEFORE_ROOT}")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS_BEFORE_ROOT}")
    set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS_BEFORE_ROOT}")
    message(STATUS "ROOT_FOUND:     ${ROOT_FOUND}")
    message(STATUS "ROOT_USE_FILE ${ROOT_USE_FILE}")
    message(STATUS "ROOT includes:  ${ROOT_INCLUDE_DIRS}")
    message(STATUS "ROOT libraries: ${ROOT_LIBRARIES}")
    message(STATUS "ROOT definitions: ${ROOT_DEFINITIONS}")
    if(ROOT_FOUND)
        include_directories(${ROOT_INCLUDE_DIRS})
        add_definitions(-DHEPMC3_ROOTIO)
        foreach(fl ${ROOT_CXX_FLAGS})
            CHECK_CXX_COMPILER_FLAG(${fl} COMPILER_SUPPORTS_${fl})
            if(COMPILER_SUPPORTS_${fl})
                set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${fl}")
            endif()
        endforeach(fl ${ROOT_CXX_FLAGS})
        set(HEPMC3_ROOTIO_LIBRARY "-lHepMC3rootIO" )
    else()
        message(STATUS "HepMC3 warning: ROOT needed for ROOTIO but not found")
        message(STATUS "HepMC3 warning: Skipping HepMC ROOT IO libraries")
        set(HEPMC3_ENABLE_ROOTIO OFF)
    endif()
endif()

#This is a workaround for ROOT+Cmake problem.
CHECK_CXX_COMPILER_FLAG("-std=c++11" COMPILER_SUPPORTS_CXX11)
if(COMPILER_SUPPORTS_CXX11)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
else()
    set(CMAKE_CXX_STANDARD 11)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    set(CMAKE_CXX_EXTENSIONS OFF)
    if ("${CMAKE_CXX_COMPILER_ID}" MATCHES "PGI")
        set(CMAKE_CXX_EXTENSIONS ON)
    endif()
endif()
if (MSVC)
    #This is a workaround for VC memory problem and false positive warnings.
    set(MSVC_CXX_FLAGS_TO_CHECK "/bigobj" "/D _CRT_SECURE_NO_WARNINGS" "/wd4267" "/wd4244" "/wd4477")
    foreach(fl ${MSVC_CXX_FLAGS_TO_CHECK})
        CHECK_CXX_COMPILER_FLAG(${fl} COMPILER_SUPPORTS_${fl})
        if(COMPILER_SUPPORTS_${fl})
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${fl}")
        endif()
    endforeach(fl ${MSVC_CXX_FLAGS_TO_CHECK})
endif()


# add_subdirectory(json_struct)

add_subdirectory(afterburner)
add_subdirectory(benchmark)
add_subdirectory(abconv)
add_subdirectory(test)

